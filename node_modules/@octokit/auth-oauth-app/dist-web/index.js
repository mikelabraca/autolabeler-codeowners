import { getUserAgent } from 'universal-user-agent';
import { request } from '@octokit/request';
import btoa from 'btoa-lite';
import { RequestError } from '@octokit/request-error';

async function getOAuthAccessToken(state, options) {
    var _a, _b, _c, _d;
    /* istanbul ignore next: coverage probles with optional chaning */
    const authOptionsPassed = typeof ((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.auth) === null || _b === void 0 ? void 0 : _b.code) !== "undefined";
    const authOptions = authOptionsPassed
        ? /* istanbul ignore next: coverage probles with optional chaning */
            (_c = options) === null || _c === void 0 ? void 0 : _c.auth
        : state;
    if (state.token && !authOptionsPassed) {
        return state.token;
    }
    // The "/login/oauth/access_token" is not part of the REST API hosted on api.github.com,
    // instead it’s using the github.com domain.
    const route = /^https:\/\/(api\.)?github\.com$/.test(state.request.endpoint.DEFAULTS.baseUrl)
        ? "POST https://github.com/login/oauth/access_token"
        : `POST ${state.request.endpoint.DEFAULTS.baseUrl.replace("/api/v3", "/login/oauth/access_token")}`;
    /* istanbul ignore next: coverage probles with optional chaning */
    const request = ((_d = options) === null || _d === void 0 ? void 0 : _d.request) || state.request;
    const parameters = {
        headers: {
            accept: "application/json"
        },
        client_id: state.clientId,
        client_secret: state.clientSecret,
        code: authOptions.code,
        redirect_uri: authOptions.redirectUrl,
        state: authOptions.state
    };
    const response = await request(route, parameters);
    if (response.data.error !== undefined) {
        throw new RequestError(`${response.data.error_description} (${response.data.error})`, response.status, {
            headers: response.headers,
            request: request.endpoint(route, parameters)
        });
    }
    const { data } = response;
    const newToken = {
        token: data.access_token,
        scopes: data.scope.split(/,\s*/).filter(Boolean)
    };
    if (!authOptionsPassed) {
        state.token = newToken;
    }
    return newToken;
}

/**
 * An OAuth app authenticates using ?client_id=...&client_secret=... query parameters, with the
 * exception of these three endpoints, which require the client ID/secret to be sent as basic auth
 *
 * - [`POST /applications/:client_id/token`](https://developer.github.com/v3/apps/oauth_applications/#check-a-token) - Check a token
 * - [`PATCH /applications/:client_id/token`](https://developer.github.com/v3/apps/oauth_applications/#reset-a-token) - Reset a token
 * - [`DELETE /applications/:client_id/token`](https://developer.github.com/v3/apps/oauth_applications/#reset-a-token) - Delete an app token
 * - [`DELETE /applications/:client_id/grant`](https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-authorization) - Delete an app authorization
 *
 * deprecated:
 *
 * - [`GET /applications/:client_id/tokens/:access_token`](https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization) - Check an authorization
 * - [`POST /applications/:client_id/tokens/:access_token`](https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization) - Reset an authorization
 * - [`DELETE /applications/:client_id/tokens/:access_token`](https://developer.github.com/v3/apps/oauth_applications/#revoke-an-authorization-for-an-application) - Revoke an authorization for an application
 * - [`DELETE /applications/:client_id/grants/:access_token`](https://developer.github.com/v3/apps/oauth_applications/#revoke-a-grant-for-an-application) - Revoke a grant for an application
 */
const OAUTH_ROUTES_EXCEPTIONS = /\/applications\/:?[\w_]+\/(token|grant)(s\/:?[\w_]+)?($|\?)/;
function requiresBasicAuth(url) {
    return url && OAUTH_ROUTES_EXCEPTIONS.test(url);
}

async function auth(state, authOptions) {
    if (authOptions.type === "token") {
        const { token, scopes } = await getOAuthAccessToken(state, {
            auth: authOptions
        });
        return {
            type: "token",
            token,
            tokenType: "oauth",
            scopes
        };
    }
    const [headers, query] = requiresBasicAuth(authOptions.url)
        ? [
            {
                authorization: `basic ${btoa(`${state.clientId}:${state.clientSecret}`)}`
            },
            {}
        ]
        : [
            {},
            {
                client_id: state.clientId,
                client_secret: state.clientSecret
            }
        ];
    return {
        type: "oauth-app",
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        headers,
        query
    };
}

async function hook(state, request, route, parameters) {
    let endpoint = request.endpoint.merge(route, parameters);
    // Do not intercept request to retrieve a new token
    if (/\/login\/oauth\/access_token$/.test(endpoint.url)) {
        return request(endpoint);
    }
    const { token } = await getOAuthAccessToken(state, { request });
    if (!requiresBasicAuth(endpoint.url)) {
        endpoint.headers.authorization = `token ${token}`;
        return request(endpoint);
    }
    const credentials = btoa(`${state.clientId}:${state.clientSecret}`);
    endpoint.headers.authorization = `basic ${credentials}`;
    // default `:client_id` & `:access_token` URL parameters
    if (endpoint.url && /:client_id/.test(endpoint.url)) {
        endpoint = Object.assign({
            client_id: state.clientId,
            access_token: token
        }, endpoint);
    }
    const response = await request(endpoint);
    // `POST /applications/:client_id/tokens/:access_token` resets the passed token
    // and returns a new one. If that’s the current request then update internal state.
    const parsedEndpoint = request.endpoint.parse(endpoint);
    const isTokenResetRequest = parsedEndpoint.method === "POST" &&
        new RegExp(token).test(parsedEndpoint.url);
    if (isTokenResetRequest && state.token) {
        state.token.token = response.data.token;
    }
    return response;
}

const VERSION = "2.3.3";

function createOAuthAppAuth(options) {
    const state = Object.assign({
        request: request.defaults({
            headers: {
                "user-agent": `octokit-auth-oauth-app.js/${VERSION} ${getUserAgent()}`
            }
        })
    }, options);
    return Object.assign(auth.bind(null, state), {
        hook: hook.bind(null, state)
    });
}

export { createOAuthAppAuth };
//# sourceMappingURL=index.js.map
